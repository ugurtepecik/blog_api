# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rexml` gem.
# Please instead update this file by running `bin/tapioca gem rexml`.


# source://rexml//lib/rexml/encoding.rb#4
module REXML::Encoding
  # source://rexml//lib/rexml/encoding.rb#29
  def decode(string); end

  # source://rexml//lib/rexml/encoding.rb#25
  def encode(string); end

  # ID ---> Encoding name
  #
  # source://rexml//lib/rexml/encoding.rb#6
  def encoding; end

  # source://rexml//lib/rexml/encoding.rb#7
  def encoding=(encoding); end

  private

  # source://rexml//lib/rexml/encoding.rb#34
  def find_encoding(name); end
end

# A Source that wraps an IO.  See the Source class for method
# documentation
#
# source://rexml//lib/rexml/source.rb#215
class REXML::IOSource < ::REXML::Source
  # block_size has been deprecated
  #
  # @return [IOSource] a new instance of IOSource
  #
  # source://rexml//lib/rexml/source.rb#219
  def initialize(arg, block_size = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # @return the current line in the source
  #
  # source://rexml//lib/rexml/source.rb#324
  def current_line; end

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/source.rb#319
  def empty?; end

  # source://rexml//lib/rexml/source.rb#279
  def ensure_buffer; end

  # source://rexml//lib/rexml/source.rb#283
  def match(pattern, cons = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/source.rb#302
  def match?(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#240
  def read(term = T.unsafe(nil), min_bytes = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#261
  def read_until(term); end

  private

  # source://rexml//lib/rexml/source.rb#371
  def encoding_updated; end

  # source://rexml//lib/rexml/source.rb#346
  def readline(term = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/parseexception.rb#3
class REXML::ParseException < ::RuntimeError
  # @return [ParseException] a new instance of ParseException
  #
  # source://rexml//lib/rexml/parseexception.rb#6
  def initialize(message, source = T.unsafe(nil), parser = T.unsafe(nil), exception = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parseexception.rb#49
  def context; end

  # Returns the value of attribute continued_exception.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception; end

  # Sets the attribute continued_exception
  #
  # @param value the value to set the attribute continued_exception to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#44
  def line; end

  # Returns the value of attribute parser.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def parser; end

  # Sets the attribute parser
  #
  # @param value the value to set the attribute parser to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def parser=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#39
  def position; end

  # Returns the value of attribute source.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def source; end

  # Sets the attribute source
  #
  # @param value the value to set the attribute source to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def source=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#13
  def to_s; end
end

# = Using the Pull Parser
# <em>This API is experimental, and subject to change.</em>
#  parser = PullParser.new( "<a>text<b att='val'/>txet</a>" )
#  while parser.has_next?
#    res = parser.next
#    puts res[1]['att'] if res.start_tag? and res[0] == 'b'
#  end
# See the PullEvent class for information on the content of the results.
# The data is identical to the arguments passed for the various events to
# the StreamListener API.
#
# Notice that:
#  parser = PullParser.new( "<a>BAD DOCUMENT" )
#  while parser.has_next?
#    res = parser.next
#    raise res[1] if res.error?
#  end
#
# Nat Price gave me some good ideas for the API.
#
# source://rexml//lib/rexml/parsers/baseparser.rb#57
class REXML::Parsers::BaseParser
  # @return [BaseParser] a new instance of BaseParser
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#163
  def initialize(source); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#173
  def add_listener(listener); end

  # Returns true if there are no more events
  #
  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#208
  def empty?; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#543
  def entity(reference, entities); end

  # Returns the value of attribute entity_expansion_count.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#178
  def entity_expansion_count; end

  # Sets the attribute entity_expansion_limit
  #
  # @param value the value to set the attribute entity_expansion_limit to.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#179
  def entity_expansion_limit=(_arg0); end

  # Sets the attribute entity_expansion_text_limit
  #
  # @param value the value to set the attribute entity_expansion_text_limit to.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#180
  def entity_expansion_text_limit=(_arg0); end

  # Returns true if there are more events.  Synonymous with !empty?
  #
  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#213
  def has_next?; end

  # Escapes all possible entities
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#554
  def normalize(input, entities = T.unsafe(nil), entity_filter = T.unsafe(nil)); end

  # Peek at the +depth+ event in the stack.  The first element on the stack
  # is at depth 0.  If +depth+ is -1, will parse to the end of the input
  # stream and return the last event, which is always :end_document.
  # Be aware that this causes the stream to be parsed up to the +depth+
  # event, so you can effectively pre-parse the entire document (pull the
  # entire thing into memory) using this method.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#229
  def peek(depth = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#198
  def position; end

  # Returns the next event.  This is a +PullEvent+ object.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#244
  def pull; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#187
  def reset; end

  # Returns the value of attribute source.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#177
  def source; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#182
  def stream=(source); end

  # Unescapes all possible entities
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#570
  def unnormalize(string, entities = T.unsafe(nil), filter = T.unsafe(nil)); end

  # Push an event back on the head of the stream.  This method
  # has (theoretically) infinite depth.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#219
  def unshift(token); end

  private

  # source://rexml//lib/rexml/parsers/baseparser.rb#619
  def add_namespace(prefix, uri); end

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#652
  def need_source_encoding_update?(xml_declaration_encoding); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#791
  def parse_attributes(prefixes); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#671
  def parse_id(base_error_message, accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#699
  def parse_id_invalid_details(accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#658
  def parse_name(base_error_message); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#634
  def pop_namespaces_restore; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#737
  def process_instruction; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#254
  def pull_event; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#628
  def push_namespaces_restore; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#645
  def record_entity_expansion(delta = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#777
  def scan_quote; end
end

# source://rexml//lib/rexml/parsers/baseparser.rb#130
REXML::Parsers::BaseParser::EXTERNAL_ID_PUBLIC = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#131
REXML::Parsers::BaseParser::EXTERNAL_ID_SYSTEM = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#132
REXML::Parsers::BaseParser::PUBLIC_ID = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#143
module REXML::Parsers::BaseParser::Private; end

# source://rexml//lib/rexml/parsers/baseparser.rb#147
REXML::Parsers::BaseParser::Private::ATTLISTDECL_END = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#152
REXML::Parsers::BaseParser::Private::CARRIAGE_RETURN_NEWLINE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#153
REXML::Parsers::BaseParser::Private::CHARACTER_REFERENCES = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#146
REXML::Parsers::BaseParser::Private::CLOSE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#154
REXML::Parsers::BaseParser::Private::DEFAULT_ENTITIES_PATTERNS = T.let(T.unsafe(nil), Hash)

# source://rexml//lib/rexml/parsers/baseparser.rb#151
REXML::Parsers::BaseParser::Private::ENTITYDECL_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#149
REXML::Parsers::BaseParser::Private::GEDECL_PATTERN = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/baseparser.rb#148
REXML::Parsers::BaseParser::Private::NAME_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#150
REXML::Parsers::BaseParser::Private::PEDECL_PATTERN = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/baseparser.rb#144
REXML::Parsers::BaseParser::Private::PEREFERENCE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#145
REXML::Parsers::BaseParser::Private::TAG_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#159
REXML::Parsers::BaseParser::Private::XML_PREFIXED_NAMESPACE = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/baseparser.rb#66
REXML::Parsers::BaseParser::QNAME = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#65
REXML::Parsers::BaseParser::QNAME_STR = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/security.rb#3
module REXML::Security
  class << self
    # Get the entity expansion limit. By default the limit is set to 10000.
    #
    # source://rexml//lib/rexml/security.rb#12
    def entity_expansion_limit; end

    # Set the entity expansion limit. By default the limit is set to 10000.
    #
    # source://rexml//lib/rexml/security.rb#7
    def entity_expansion_limit=(val); end

    # Get the entity expansion limit. By default the limit is set to 10240.
    #
    # source://rexml//lib/rexml/security.rb#24
    def entity_expansion_text_limit; end

    # Set the entity expansion limit. By default the limit is set to 10240.
    #
    # source://rexml//lib/rexml/security.rb#19
    def entity_expansion_text_limit=(val); end
  end
end

# A Source can be searched for patterns, and wraps buffers and other
# objects and provides consumption of text
#
# source://rexml//lib/rexml/source.rb#61
class REXML::Source
  include ::REXML::Encoding

  # Constructor
  # value, overriding all encoding detection
  #
  # @param arg must be a String, and should be a valid XML document
  # @param encoding if non-null, sets the encoding of the source to this
  # @return [Source] a new instance of Source
  #
  # source://rexml//lib/rexml/source.rb#87
  def initialize(arg, encoding = T.unsafe(nil)); end

  # The current buffer (what we're going to read next)
  #
  # source://rexml//lib/rexml/source.rb#100
  def buffer; end

  # source://rexml//lib/rexml/source.rb#110
  def buffer_encoding=(encoding); end

  # @return the current line in the source
  #
  # source://rexml//lib/rexml/source.rb#175
  def current_line; end

  # source://rexml//lib/rexml/source.rb#104
  def drop_parsed_content; end

  # @return [Boolean] true if the Source is exhausted
  #
  # source://rexml//lib/rexml/source.rb#170
  def empty?; end

  # Returns the value of attribute encoding.
  #
  # source://rexml//lib/rexml/source.rb#65
  def encoding; end

  # Inherited from Encoding
  # Overridden to support optimized en/decoding
  #
  # source://rexml//lib/rexml/source.rb#116
  def encoding=(enc); end

  # source://rexml//lib/rexml/source.rb#134
  def ensure_buffer; end

  # The line number of the last consumed text
  #
  # source://rexml//lib/rexml/source.rb#64
  def line; end

  # source://rexml//lib/rexml/source.rb#137
  def match(pattern, cons = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/source.rb#145
  def match?(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#161
  def peek_byte; end

  # source://rexml//lib/rexml/source.rb#153
  def position; end

  # source://rexml//lib/rexml/source.rb#157
  def position=(pos); end

  # source://rexml//lib/rexml/source.rb#121
  def read(term = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#124
  def read_until(term); end

  # source://rexml//lib/rexml/source.rb#165
  def scan_byte; end

  private

  # source://rexml//lib/rexml/source.rb#184
  def detect_encoding; end

  # source://rexml//lib/rexml/source.rb#202
  def encoding_updated; end
end

# source://rexml//lib/rexml/source.rb#67
module REXML::Source::Private; end

# source://rexml//lib/rexml/source.rb#69
REXML::Source::Private::PRE_DEFINED_TERM_PATTERNS = T.let(T.unsafe(nil), Hash)

# source://rexml//lib/rexml/source.rb#68
REXML::Source::Private::SCANNER_RESET_SIZE = T.let(T.unsafe(nil), Integer)

# Generates Source-s.  USE THIS CLASS.
#
# source://rexml//lib/rexml/source.rb#38
class REXML::SourceFactory
  class << self
    # Generates a Source object
    #
    # @param arg Either a String, or an IO
    # @return a Source, or nil if a bad argument was given
    #
    # source://rexml//lib/rexml/source.rb#42
    def create_from(arg); end
  end
end

# source://rexml//lib/rexml/undefinednamespaceexception.rb#4
class REXML::UndefinedNamespaceException < ::REXML::ParseException
  # @return [UndefinedNamespaceException] a new instance of UndefinedNamespaceException
  #
  # source://rexml//lib/rexml/undefinednamespaceexception.rb#5
  def initialize(prefix, source, parser); end
end
