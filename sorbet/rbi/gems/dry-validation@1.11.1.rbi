# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-validation` gem.
# Please instead update this file by running `bin/tapioca gem dry-validation`.


# Main namespace
#
# @api public
#
# source://dry-validation//lib/dry/validation/constants.rb#6
module Dry
  class << self
    # source://dry-configurable/1.3.0/lib/dry/configurable.rb#11
    def Configurable(**options); end

    # source://dry-core/1.1.0/lib/dry/core.rb#52
    def Equalizer(*keys, **options); end

    # source://dry-struct/1.8.0/lib/dry/struct.rb#30
    def Struct(attributes = T.unsafe(nil), &block); end

    # source://dry-types/1.8.2/lib/dry/types.rb#253
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# source://dry-validation//lib/dry/validation/schema_ext.rb#6
module Dry::Schema
  class << self
    # source://dry-schema/1.14.1/lib/dry/schema.rb#86
    def Form(**options, &_arg1); end

    # source://dry-schema/1.14.1/lib/dry/schema.rb#106
    def JSON(**options, &_arg1); end

    # source://dry-schema/1.14.1/lib/dry/schema.rb#86
    def Params(**options, &_arg1); end

    # source://dry-schema/1.14.1/lib/dry/schema.rb#48
    def config; end

    # source://dry-schema/1.14.1/lib/dry/schema.rb#67
    def define(*_arg0, **_arg1, &_arg2); end

    # source://dry-schema/1.14.1/lib/dry/schema.rb#18
    def loader; end
  end
end

# source://dry-validation//lib/dry/validation/schema_ext.rb#7
class Dry::Schema::Path
  # source://dry-schema/1.14.1/lib/dry/schema/path.rb#57
  def initialize(keys); end

  # source://dry-schema/1.14.1/lib/dry/schema/path.rb#88
  def &(other); end

  # source://dry-schema/1.14.1/lib/dry/schema/path.rb#79
  def <=>(other); end

  # source://dry-schema/1.14.1/lib/dry/schema/path.rb#69
  def each(&_arg0); end

  # @api private
  #
  # source://dry-validation//lib/dry/validation/schema_ext.rb#14
  def expand; end

  # source://dry-schema/1.14.1/lib/dry/schema/path.rb#74
  def include?(other); end

  # source://dry-schema/1.14.1/lib/dry/schema/path.rb#16
  def keys; end

  # source://dry-schema/1.14.1/lib/dry/schema/path.rb#95
  def last; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/schema_ext.rb#9
  def multi_value?; end

  def root(*_arg0); end

  # source://dry-schema/1.14.1/lib/dry/schema/path.rb#100
  def same_root?(other); end

  # source://dry-schema/1.14.1/lib/dry/schema/path.rb#62
  def to_h(value = T.unsafe(nil)); end

  class << self
    # source://dry-schema/1.14.1/lib/dry/schema/path.rb#43
    def [](spec); end

    # source://dry-schema/1.14.1/lib/dry/schema/path.rb#27
    def call(spec); end

    # source://dry-schema/1.14.1/lib/dry/schema/path.rb#50
    def keys_from_hash(hash); end
  end
end

# Main library namespace
#
# @api public
#
# source://dry-validation//lib/dry/validation/constants.rb#7
module Dry::Validation
  include ::Dry::Core::Constants
  extend ::Dry::Core::Extensions
  extend ::Dry::Validation::Macros::Registrar

  class << self
    # Define a contract and build its instance
    #
    # @api public
    # @example
    #   my_contract = Dry::Validation.Contract do
    #   params do
    #   required(:name).filled(:string)
    #   end
    #   end
    #
    #   my_contract.call(name: "Jane")
    # @param options [Hash] Contract options
    # @return [Contract]
    # @see Contract
    #
    # source://dry-validation//lib/dry/validation.rb#67
    def Contract(options = T.unsafe(nil), &_arg1); end

    # @api public
    #
    # source://dry-validation//lib/dry/validation.rb#20
    def loader; end

    # This is needed by Macros::Registrar
    #
    # @api private
    #
    # source://dry-validation//lib/dry/validation.rb#74
    def macros; end
  end
end

# Mapping for block kwarg options used by block_options
#
# @see Rule#block_options
#
# source://dry-validation//lib/dry/validation/constants.rb#24
Dry::Validation::BLOCK_OPTIONS_MAPPINGS = T.let(T.unsafe(nil), Hash)

# Configuration for contracts
#
# @api public
# @see Contract#config
#
# source://dry-validation//lib/dry/validation/config.rb#10
class Dry::Validation::Config < ::Dry::Schema::Config
  # @api private
  #
  # source://dry-validation//lib/dry/validation/config.rb#14
  def dup; end
end

# Extension to use dry-logic predicates as macros.
#
# @api public
# @example
#   Dry::Validation.load_extensions(:predicates_as_macros)
#
#   class ApplicationContract < Dry::Validation::Contract
#   import_predicates_as_macros
#   end
#
#   class AgeContract < ApplicationContract
#   schema do
#   required(:age).filled(:integer)
#   end
#
#   rule(:age).validate(gteq?: 18)
#   end
#
#   AgeContract.new.(age: 17).errors.first.text
#   # => 'must be greater than or equal to 18'
# @see Dry::Validation::PredicateRegistry::WHITELIST Available predicates
#
# source://dry-validation//lib/dry/validation/contract.rb#43
class Dry::Validation::Contract
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer
  extend ::Dry::Validation::Macros::Registrar
  extend ::Dry::Validation::Contract::ClassInterface

  # Apply the contract to an input
  #
  #
  # @api public
  # @param input [Hash] The input to validate
  # @param context [Hash] Initial context for rules
  # @return [Result]
  #
  # source://dry-validation//lib/dry/validation/contract.rb#92
  def call(input, context = T.unsafe(nil)); end

  # Return a nice string representation
  #
  # @api public
  # @return [String]
  #
  # source://dry-validation//lib/dry/validation/contract.rb#119
  def inspect; end

  private

  # @api private
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/contract.rb#126
  def error?(result, spec); end

  # Get a registered macro
  #
  # @api private
  # @return [Proc, #to_proc]
  #
  # source://dry-validation//lib/dry/validation/contract.rb#154
  def macro(name, *args); end

  # Return configured messages backend
  #
  # @api private
  # @return [Dry::Schema::Messages::YAML, Dry::Schema::Messages::I18n]
  #
  # source://dry-validation//lib/dry/validation/contract.rb#163
  def messages; end

  # @api public
  # @raise [::ArgumentError]
  #
  # source://dry-validation//lib/dry/validation/contract.rb#167
  def validate_input_type(input); end
end

# Contract's class interface
#
# @api public
# @see Contract
#
# source://dry-validation//lib/dry/validation/contract/class_interface.rb#13
module Dry::Validation::Contract::ClassInterface
  include ::Dry::Validation::Macros::Registrar

  # @api private
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#123
  def __schema__; end

  # A shortcut that can be used to define contracts that won't be reused or inherited
  #
  # @api public
  # @example
  #   my_contract = Dry::Validation::Contract.build do
  #   params do
  #   required(:name).filled(:string)
  #   end
  #   end
  #
  #   my_contract.call(name: "Jane")
  # @return [Contract]
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#118
  def build(options = T.unsafe(nil), &_arg1); end

  # Configuration
  #
  # @api public
  # @example
  #   class MyContract < Dry::Validation::Contract
  #   config.messages.backend = :i18n
  #   end
  # @return [Config]
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#32
  def config; end

  # @api private
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#17
  def inherited(klass); end

  # Define a JSON schema for your contract
  #
  # This type of schema is suitable for JSON data
  #
  # @api public
  # @return [Dry::Schema::JSON, NilClass]
  # @see https://dry-rb.org/gems/dry-schema/json/
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#65
  def json(*external_schemas, &_arg1); end

  # Return macros registered for this class
  #
  # @api public
  # @return [Macros::Container]
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#41
  def macros; end

  # Return messages configured for this class
  #
  # @api private
  # @return [Dry::Schema::Messages]
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#143
  def messages; end

  # Define a params schema for your contract
  #
  # This type of schema is suitable for HTTP parameters
  #
  # @api public
  # @return [Dry::Schema::Params, NilClass]
  # @see https://dry-rb.org/gems/dry-schema/params/
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#53
  def params(*external_schemas, &_arg1); end

  # Define a rule for your contract
  #
  # @api public
  # @example using a symbol
  #   rule(:age) do
  #   failure('must be at least 18') if values[:age] < 18
  #   end
  # @example using a path to a value and a custom predicate
  #   rule('address.street') do
  #   failure('please provide a valid street address') if valid_street?(values[:street])
  #   end
  # @return [Rule]
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#96
  def rule(*keys, &block); end

  # Return rules defined in this class
  #
  # @api private
  # @return [Array<Rule>]
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#132
  def rules; end

  # Define a plain schema for your contract
  #
  # This type of schema does not offer coercion out of the box
  #
  # @api public
  # @return [Dry::Schema::Processor, NilClass]
  # @see https://dry-rb.org/gems/dry-schema/
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#77
  def schema(*external_schemas, &_arg1); end

  private

  # @api private
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#197
  def core_schema_opts; end

  # @api private
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#202
  def define(method_name, external_schemas, &block); end

  # @api private
  # @raise [InvalidKeysError]
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#150
  def ensure_valid_keys(*keys); end

  # @api private
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#192
  def key_map; end

  # @api private
  #
  # source://dry-validation//lib/dry/validation/contract/class_interface.rb#170
  def key_paths(keys); end
end

# Path to the default errors locale file
#
# source://dry-validation//lib/dry/validation/constants.rb#16
Dry::Validation::DEFAULT_ERRORS_NAMESPACE = T.let(T.unsafe(nil), String)

# Path to the default errors locale file
#
# source://dry-validation//lib/dry/validation/constants.rb#19
Dry::Validation::DEFAULT_ERRORS_PATH = T.let(T.unsafe(nil), Pathname)

# source://dry-validation//lib/dry/validation/constants.rb#10
Dry::Validation::DOT = T.let(T.unsafe(nil), String)

# Error raised when trying to define a schema in a contract class that already has a schema
#
# source://dry-validation//lib/dry/validation/constants.rb#33
class Dry::Validation::DuplicateSchemaError < ::StandardError; end

# Evaluator is the execution context for rules
#
# Evaluators expose an API for setting failure messages and forward
# method calls to the contracts, so that you can use your contract
# methods within rule blocks
#
# @api public
#
# source://dry-validation//lib/dry/validation/evaluator.rb#15
class Dry::Validation::Evaluator
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer
  extend ::Dry::Core::Deprecations::Interface

  # Initialize a new evaluator
  #
  # @api private
  # @return [Evaluator] a new instance of Evaluator
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#67
  def initialize(contract, **options, &block); end

  # @api public
  # @return [Hash]
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#62
  def _options; end

  # Get `Failures` object for base errors
  #
  # @api public
  # @return [Failures]
  # @see Failures#failure
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#103
  def base; end

  # Check if there are any base rule errors
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#205
  def base_rule_error?; end

  # source://dry-core/1.1.0/lib/dry/core/deprecations.rb#168
  def error?(*args, &block); end

  # Return aggregated failures
  #
  # @api private
  # @return [Array<Hash>]
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#112
  def failures; end

  # Get `Failures` object for the default or provided path
  #
  # @api public
  # @param path [Symbol, String, Hash, Array<Symbol>]
  # @return [Failures]
  # @see Failures#failure
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#92
  def key(path = T.unsafe(nil)); end

  # Return if the value under the default key is available
  #
  # This is useful when dealing with rules for optional keys
  #
  # @api public
  # @example use the default key name
  #   rule(:age) do
  #   key.failure(:invalid) if key? && value < 18
  #   end
  # @example specify the key name
  #   rule(:start_date, :end_date) do
  #   if key?(:start_date) && !key?(:end_date)
  #   key(:end_date).failure("must provide an end_date with start_date")
  #   end
  #   end
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#170
  def key?(name = T.unsafe(nil)); end

  # Return default (first) key name
  #
  # @api public
  # @return [Symbol]
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#129
  def key_name; end

  # Check if there are any errors on the current rule
  #
  # @api public
  # @param path [Symbol, String, Array] A Path-compatible spec
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#192
  def rule_error?(path = T.unsafe(nil)); end

  # Check if there are any errors on the schema under the provided path
  #
  # @api public
  # @param path [Symbol, String, Array] A Path-compatible spec
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#181
  def schema_error?(path); end

  # Return the value found under the first specified key
  #
  # This is a convenient method that can be used in all the common cases
  # where a rule depends on just one key and you want a quick access to
  # the value
  #
  # @api public
  # @example
  #   rule(:age) do
  #   key.failure(:invalid) if value < 18
  #   end
  # @return [Object]
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#147
  def value; end

  # @api private
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#120
  def with(new_opts, &_arg1); end

  private

  # Forward to the underlying contract
  #
  # @api private
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#219
  def method_missing(meth, *_arg1, **_arg2, &_arg3); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/evaluator.rb#210
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# Failure accumulator object
#
# @api public
#
# source://dry-validation//lib/dry/validation/failures.rb#11
class Dry::Validation::Failures
  # @api private
  # @return [Failures] a new instance of Failures
  #
  # source://dry-validation//lib/dry/validation/failures.rb#29
  def initialize(path = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/failures.rb#65
  def empty?; end

  # Set failure
  #
  # @api public
  # @overload failure
  # @overload failure
  # @overload failure
  # @see Evaluator#key
  # @see Evaluator#base
  #
  # source://dry-validation//lib/dry/validation/failures.rb#59
  def failure(message, tokens = T.unsafe(nil)); end

  # Options for messages
  #
  # These options are used by MessageResolver
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-validation//lib/dry/validation/failures.rb#26
  def opts; end

  # The path for messages accumulated by failures object
  #
  # @api private
  # @return [Dry::Schema::Path]
  #
  # source://dry-validation//lib/dry/validation/failures.rb#17
  def path; end
end

# Abstract class for handling rule blocks
#
# @api private
# @see Rule
# @see Macro
#
# source://dry-validation//lib/dry/validation/function.rb#14
class Dry::Validation::Function
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  private

  # Extract options for the block kwargs
  #
  # @api private
  # @param block [Proc] Callable
  # @return Hash
  #
  # source://dry-validation//lib/dry/validation/function.rb#35
  def map_keywords(block); end
end

# Error raised when `rule` specifies one or more keys that the schema doesn't specify
#
# source://dry-validation//lib/dry/validation/constants.rb#27
class Dry::Validation::InvalidKeysError < ::StandardError; end

# A wrapper for macro validation blocks
#
# @api public
#
# source://dry-validation//lib/dry/validation/macro.rb#10
class Dry::Validation::Macro < ::Dry::Validation::Function
  # @api private
  #
  # source://dry-validation//lib/dry/validation/macro.rb#32
  def extract_block_options(options); end

  # @api private
  #
  # source://dry-validation//lib/dry/validation/macro.rb#27
  def with(args); end
end

# API for registering and accessing Rule macros
#
# @api public
#
# source://dry-validation//lib/dry/validation/macros.rb#8
module Dry::Validation::Macros
  class << self
    # Return a registered macro
    #
    # @api public
    # @param name [Symbol] The name of the macro
    # @return [Proc]
    #
    # source://dry-validation//lib/dry/validation/macros.rb#72
    def [](name); end

    # @api private
    #
    # source://dry-validation//lib/dry/validation/macros.rb#89
    def container; end

    # Register a global macro
    #
    # @api public
    # @return [Macros]
    # @see Container#register
    #
    # source://dry-validation//lib/dry/validation/macros.rb#83
    def register(*_arg0, **_arg1, &_arg2); end
  end
end

# Registry for macros
#
# @api public
#
# source://dry-validation//lib/dry/validation/macros.rb#41
class Dry::Validation::Macros::Container
  include ::Dry::Core::Container::Mixin::Initializer
  include ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # source://dry-core/1.1.0/lib/dry/core/container/mixin.rb#83
  def config; end

  # Register a new macro
  #
  # @api public
  # @example in a contract class
  #   class MyContract < Dry::Validation::Contract
  #   register_macro(:even_numbers) do
  #   key.failure('all numbers must be even') unless values[key_name].all?(&:even?)
  #   end
  #   end
  # @param name [Symbol] The name of the macro
  # @return [self]
  #
  # source://dry-validation//lib/dry/validation/macros.rb#58
  def register(name, *args, &block); end
end

# @api public
#
# source://dry-validation//lib/dry/validation/macros.rb#9
module Dry::Validation::Macros::Registrar
  # Register a macro
  #
  # @api public
  # @example register a global macro
  #   Dry::Validation.register_macro(:even_numbers) do
  #   key.failure('all numbers must be even') unless values[key_name].all?(&:even?)
  #   end
  # @example register a contract macro
  #   class MyContract < Dry::Validation::Contract
  #   register_macro(:even_numbers) do
  #   key.failure('all numbers must be even') unless values[key_name].all?(&:even?)
  #   end
  #   end
  # @param name [Symbol] The name of the macro
  # @param args [Array] Optional default positional arguments for the macro
  # @return [self]
  # @see Macro
  #
  # source://dry-validation//lib/dry/validation/macros.rb#32
  def register_macro(*_arg0, **_arg1, &_arg2); end
end

# Message message
#
# @api public
#
# source://dry-validation//lib/dry/validation/message.rb#8
class Dry::Validation::Message < ::Dry::Schema::Message
  # Initialize a new error object
  #
  #
  # @api private
  # @return [Message] a new instance of Message
  #
  # source://dry-validation//lib/dry/validation/message.rb#69
  def initialize(text, path:, meta: T.unsafe(nil)); end

  # Check if this is a base error not associated with any key
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/message.rb#81
  def base?; end

  # Optional hash with meta-data
  #
  # @api public
  # @return [Hash]
  #
  # source://dry-validation//lib/dry/validation/message.rb#30
  def meta; end

  # The path to the value with the error
  #
  # @api public
  # @return [Array<Symbol, Integer>]
  #
  # source://dry-validation//lib/dry/validation/message.rb#23
  def path; end

  # The error message text
  #
  # @api public
  # @return [String] text
  #
  # source://dry-validation//lib/dry/validation/message.rb#16
  def text; end

  # Dump error to a string
  #
  # @api public
  # @return [String]
  #
  # source://dry-validation//lib/dry/validation/message.rb#90
  def to_s; end

  class << self
    # Build an error
    #
    # @api private
    # @return [Message, Message::Localized]
    #
    # source://dry-validation//lib/dry/validation/message.rb#60
    def [](text, path, meta); end
  end
end

# A localized message type
#
# Localized messsages can be translated to other languages at run-time
#
# @api public
#
# source://dry-validation//lib/dry/validation/message.rb#37
class Dry::Validation::Message::Localized < ::Dry::Validation::Message
  # Evaluate message text using provided locale
  #
  # @api public
  # @example
  #   result.errors[:email].evaluate(locale: :en, full: true)
  #   # "email is invalid"
  # @option opts
  # @option opts
  # @param opts [Hash]
  #
  # source://dry-validation//lib/dry/validation/message.rb#49
  def evaluate(**opts); end
end

# MessageSet is a specialized message set for handling validation messages
#
# @api public
#
# source://dry-validation//lib/dry/validation/message_set.rb#10
class Dry::Validation::MessageSet < ::Dry::Schema::MessageSet
  # @api private
  # @return [MessageSet] a new instance of MessageSet
  #
  # source://dry-validation//lib/dry/validation/message_set.rb#26
  def initialize(messages, options = T.unsafe(nil)); end

  # Add a new message
  #
  # This is used when result is being prepared
  #
  # @api private
  # @return [MessageSet]
  #
  # source://dry-validation//lib/dry/validation/message_set.rb#53
  def add(message); end

  # Filter message set using provided predicates
  #
  # This method is open to any predicate because messages can be anything that
  # implements Message API, thus they can implement whatever predicates you
  # may need.
  #
  # @api public
  # @example get a list of base messages
  #   message_set = contract.(input).errors
  #   message_set.filter(:base?)
  # @param predicates [Array<Symbol>]
  # @return [MessageSet]
  #
  # source://dry-validation//lib/dry/validation/message_set.rb#75
  def filter(*predicates); end

  # @api private
  #
  # source://dry-validation//lib/dry/validation/message_set.rb#83
  def freeze; end

  # Configured locale
  #
  # @api public
  # @return [Symbol]
  #
  # source://dry-validation//lib/dry/validation/message_set.rb#23
  def locale; end

  # Return the source set of messages used to produce final evaluated messages
  #
  # @api private
  # @return [Array<Message, Message::Localized, Schema::Message>]
  #
  # source://dry-validation//lib/dry/validation/message_set.rb#16
  def source_messages; end

  # Return a new message set using updated options
  #
  # @api private
  # @return [MessageSet]
  #
  # source://dry-validation//lib/dry/validation/message_set.rb#37
  def with(other, new_options = T.unsafe(nil)); end
end

# source://dry-validation//lib/dry/validation/messages/resolver.rb#5
module Dry::Validation::Messages; end

# source://dry-validation//lib/dry/validation/messages/resolver.rb#6
Dry::Validation::Messages::FULL_MESSAGE_WHITESPACE = T.let(T.unsafe(nil), Hash)

# Resolve translated messages from failure arguments
#
# @api public
#
# source://dry-validation//lib/dry/validation/messages/resolver.rb#11
class Dry::Validation::Messages::Resolver
  # @api private
  # @return [Resolver] a new instance of Resolver
  #
  # source://dry-validation//lib/dry/validation/messages/resolver.rb#18
  def initialize(messages); end

  # Resolve Message object from provided args and path
  #
  # This is used internally by contracts when rules are applied
  # If message argument is a Hash, then it MUST have a :text key,
  # which value will be used as the message value
  #
  # @api public
  # @return [Message, Message::Localized]
  #
  # source://dry-validation//lib/dry/validation/messages/resolver.rb#31
  def [](message:, tokens:, path:, meta: T.unsafe(nil)); end

  # Resolve Message object from provided args and path
  #
  # This is used internally by contracts when rules are applied
  # If message argument is a Hash, then it MUST have a :text key,
  # which value will be used as the message value
  #
  # @api public
  # @return [Message, Message::Localized]
  #
  # source://dry-validation//lib/dry/validation/messages/resolver.rb#31
  def call(message:, tokens:, path:, meta: T.unsafe(nil)); end

  # Resolve a message
  #
  #
  # @api public
  # @return [String]
  #
  # source://dry-validation//lib/dry/validation/messages/resolver.rb#62
  def message(rule, path:, tokens: T.unsafe(nil), locale: T.unsafe(nil), full: T.unsafe(nil)); end

  # @api public
  #
  # source://dry-validation//lib/dry/validation/messages/resolver.rb#15
  def messages; end

  private

  # @api public
  #
  # source://dry-validation//lib/dry/validation/messages/resolver.rb#102
  def key_text(path:, locale: T.unsafe(nil)); end

  # @api public
  #
  # source://dry-validation//lib/dry/validation/messages/resolver.rb#94
  def message_text(text, path:, locale: T.unsafe(nil), full: T.unsafe(nil)); end

  # @api public
  #
  # source://dry-validation//lib/dry/validation/messages/resolver.rb#115
  def parse_token(token); end

  # @api public
  #
  # source://dry-validation//lib/dry/validation/messages/resolver.rb#111
  def parse_tokens(tokens); end
end

# Error raised when a localized message was not found
#
# source://dry-validation//lib/dry/validation/constants.rb#30
class Dry::Validation::MissingMessageError < ::StandardError; end

# Root path is used for base errors in hash representation of error messages
#
# source://dry-validation//lib/dry/validation/constants.rb#13
Dry::Validation::ROOT_PATH = T.let(T.unsafe(nil), Array)

# Result objects are returned by contracts
#
# @api public
#
# source://dry-validation//lib/dry/validation/result.rb#12
class Dry::Validation::Result
  include ::Dry::Core::Equalizer::Methods

  # Initialize a new result
  #
  # @api private
  # @return [Result] a new instance of Result
  #
  # source://dry-validation//lib/dry/validation/result.rb#50
  def initialize(schema_result, context, options); end

  # Read a value under provided key
  #
  # @api public
  # @param key [Symbol]
  # @return [Object]
  #
  # source://dry-validation//lib/dry/validation/result.rb#158
  def [](key); end

  # Add a new error for the provided key
  #
  # @api private
  #
  # source://dry-validation//lib/dry/validation/result.rb#146
  def add_error(error); end

  # Check if there's any error for the provided key
  #
  # This does not consider errors from the nested values
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/result.rb#132
  def base_error?(key); end

  # Check if the result contains any base rule errors
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/result.rb#123
  def base_rule_error?; end

  # Context that's shared between rules
  #
  # @api public
  # @return [Concurrent::Map]
  #
  # source://dry-validation//lib/dry/validation/result.rb#31
  def context; end

  # Pattern matching
  #
  # @api private
  #
  # source://dry-validation//lib/dry/validation/result.rb#210
  def deconstruct; end

  # Pattern matching
  #
  # @api private
  #
  # source://dry-validation//lib/dry/validation/result.rb#203
  def deconstruct_keys(keys); end

  # Check if values include an error for the provided key
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/result.rb#102
  def error?(key); end

  # Get error set
  #
  # @api public
  # @option new_options
  # @option new_options
  # @option new_options
  # @param new_options [Hash]
  # @return [MessageSet]
  #
  # source://dry-validation//lib/dry/validation/result.rb#77
  def errors(new_options = T.unsafe(nil)); end

  # Check if result is not successful
  #
  # @api public
  # @return [Bool]
  #
  # source://dry-validation//lib/dry/validation/result.rb#95
  def failure?; end

  # Freeze result and its error set
  #
  # @api private
  #
  # source://dry-validation//lib/dry/validation/result.rb#194
  def freeze; end

  # Return a string representation
  #
  # @api public
  #
  # source://dry-validation//lib/dry/validation/result.rb#183
  def inspect; end

  # Check if a key was set
  #
  # @api public
  # @param key [Symbol]
  # @return [Bool]
  #
  # source://dry-validation//lib/dry/validation/result.rb#169
  def key?(key); end

  # Result options
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-validation//lib/dry/validation/result.rb#45
  def options; end

  # Check if the rules includes an error for the provided key
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/result.rb#116
  def rule_error?(key); end

  # Check if the base schema (without rules) includes an error for the provided key
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/result.rb#109
  def schema_error?(key); end

  # Result from contract's schema
  #
  # @api private
  # @return [Dry::Schema::Result]
  #
  # source://dry-validation//lib/dry/validation/result.rb#38
  def schema_result; end

  # Check if result is successful
  #
  # @api public
  # @return [Bool]
  #
  # source://dry-validation//lib/dry/validation/result.rb#86
  def success?; end

  # Coerce to a hash
  #
  # @api public
  #
  # source://dry-validation//lib/dry/validation/result.rb#176
  def to_h; end

  # Return values wrapper with the input processed by schema
  #
  # @api public
  # @return [Values]
  #
  # source://dry-validation//lib/dry/validation/result.rb#62
  def values; end

  private

  # @api private
  #
  # source://dry-validation//lib/dry/validation/result.rb#217
  def initialize_errors(options = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-validation//lib/dry/validation/result.rb#222
  def schema_errors(options); end

  class << self
    # Build a new result
    #
    # @api private
    # @param schema_result [Dry::Schema::Result]
    # @yield [result]
    #
    # source://dry-validation//lib/dry/validation/result.rb#20
    def new(schema_result, context = T.unsafe(nil), options = T.unsafe(nil)); end
  end
end

# Rules capture configuration and evaluator blocks
#
# When a rule is applied, it creates an `Evaluator` using schema result and its
# block will be evaluated in the context of the evaluator.
#
# @api public
# @see Contract#rule
#
# source://dry-validation//lib/dry/validation/rule.rb#15
class Dry::Validation::Rule < ::Dry::Validation::Function
  include ::Dry::Core::Equalizer::Methods

  # @api public
  #
  # source://dry-validation//lib/dry/validation/rule.rb#128
  def add_macro_from_hash(macros, spec); end

  # Evaluate the rule within the provided context
  #
  # @api private
  # @param contract [Contract]
  # @param result [Result]
  #
  # source://dry-validation//lib/dry/validation/rule.rb#34
  def call(contract, result); end

  # Define a validation function for each element of an array
  #
  # The function will be applied only if schema checks passed
  # for a given array item.
  #
  #
  # @api public
  # @example
  #   rule(:nums).each do |index:|
  #   key([:number, index]).failure("must be greater than 0") if value < 0
  #   end
  #   rule(:nums).each(min: 3)
  #   rule(address: :city) do
  #   key.failure("oops") if value != 'Munich'
  #   end
  # @return [Rule]
  #
  # source://dry-validation//lib/dry/validation/rule.rb#78
  def each(*macros, &block); end

  # Return a nice string representation
  #
  # @api public
  # @return [String]
  #
  # source://dry-validation//lib/dry/validation/rule.rb#108
  def inspect; end

  # Parse function arguments into macros structure
  #
  # @api private
  # @return [Array]
  #
  # source://dry-validation//lib/dry/validation/rule.rb#117
  def parse_macros(*args); end

  # Define which macros should be executed
  #
  # @api public
  # @return [Rule]
  # @see Contract#rule
  #
  # source://dry-validation//lib/dry/validation/rule.rb#53
  def validate(*macros, &block); end
end

# Error raised during initialization of a contract that has no schema defined
#
# source://dry-validation//lib/dry/validation/constants.rb#36
class Dry::Validation::SchemaMissingError < ::StandardError
  # source://dry-validation//lib/dry/validation/constants.rb#38
  def initialize(klass); end
end

# A convenient wrapper for data processed by schemas
#
# Values are available within the rule blocks. They act as hash-like
# objects and expose a convenient API for accessing data.
#
# @api public
#
# source://dry-validation//lib/dry/validation/values.rb#14
class Dry::Validation::Values
  include ::Enumerable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Values] a new instance of Values
  #
  # source://dry-validation//lib/dry/validation/values.rb#26
  def initialize(data); end

  # Read from the provided key
  #
  # @api public
  # @example
  #   rule(:age) do
  #   key.failure('must be > 18') if values[:age] <= 18
  #   end
  # @param args [Symbol, String, Hash, Array<Symbol>] If given as a single
  #   Symbol, String, Array or Hash, build a key array using
  #   {Dry::Schema::Path} digging for data. If given as positional
  #   arguments, use these with Hash#dig on the data directly.
  # @return [Object]
  #
  # source://dry-validation//lib/dry/validation/values.rb#45
  def [](*args); end

  # Schema's result output
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-validation//lib/dry/validation/values.rb#23
  def data; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/values.rb#64
  def key?(key, hash = T.unsafe(nil)); end

  private

  # @api private
  #
  # source://dry-validation//lib/dry/validation/values.rb#90
  def method_missing(meth, *_arg1, **_arg2, &_arg3); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-validation//lib/dry/validation/values.rb#83
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end
